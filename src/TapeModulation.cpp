/*
 * Company: ChowDSP
 * Effect Name: Tape Modulation
 * Description: A modulation effect based on a physically-modelled reel-to-reel tape machine.
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#include "Aviate/EfxPrint.h"
#include "TapeModulation.h"

// teensy defines these things, which causes mad conflicts...
#undef abs
#undef round
#undef B0
#undef B1
#undef B2
#include "modulation/tape_mod_plugin.h"

// Some useful aliases, file scope only
#define audioBlockReceiveReadOnly receiveReadOnlyFloat
#define audioBlockReceiveWritable receiveWritableFloat
#define audioBlockAllocate        allocateFloat

using namespace Aviate;

namespace ChowDSP_TapeModulation {

TapeModulation::TapeModulation()
: AudioStream(NUM_INPUTS, m_inputQueueArray)
{
    // perform any necessary class initialization here
    plugin = std::make_unique<ne_pedal::plugins::tape_mod::TapeModPlugin>();
    plugin->prepare (AUDIO_SAMPLE_RATE, AUDIO_SAMPLES_PER_BLOCK);
}

TapeModulation::~TapeModulation()
{
    // perform any necessary clean up here, though destructors are not
    // called on the hardware, only in the simulator.
}

void TapeModulation::update(void)
{
    audio_block_float32_t *inputAudioBlock = receiveWritableFloat(); // get the next block of input samples
    inputAudioBlock = m_basicInputCheck(inputAudioBlock, 0); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass
    if (!inputAudioBlock) { return; } // no further processing for this update() call

    // You must call m_updateInputPeak() before processing the audio
    m_updateInputPeak(inputAudioBlock);

    // DO AUDIO EFFECT PROCESSING
    plugin->parameters[0]->set_value(m_flutterrate);
    plugin->parameters[1]->set_value(m_flutterdepth);
    plugin->parameters[2]->set_value(m_wowrate);
    plugin->parameters[3]->set_value(m_wowdepth);
    plugin->parameters[4]->set_value(m_wowvariance);
    plugin->parameters[5]->set_value(m_wowdrift);
    plugin->processBlock (chowdsp::BufferView<float> { inputAudioBlock->data, (int) AUDIO_SAMPLES_PER_BLOCK });

    arm_scale_f32 (inputAudioBlock->data, m_volume, inputAudioBlock->data, AUDIO_SAMPLES_PER_BLOCK);	


    m_updateOutputPeak(inputAudioBlock); // you must call m_upateOutputPeak() at the end of update() before transmit
    transmit(inputAudioBlock);
    release(inputAudioBlock);
}

void TapeModulation::flutterrate(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_flutterrate = value;
}
void TapeModulation::flutterdepth(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_flutterdepth = value;
}
void TapeModulation::wowrate(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_wowrate = value;
}
void TapeModulation::wowdepth(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_wowdepth = value;
}
void TapeModulation::wowvariance(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_wowvariance = value;
}
void TapeModulation::wowdrift(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_wowdrift = value;
}
void TapeModulation::volume(float value)
{
    m_volume = value;
}
}
